{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Python\ndifficulty: medium\nconcepts: This snippet is not written in Dafny, but rather in Python. It doesn't contain Dafny-specific concepts or formal verification principles. However, I can provide a list of general programming concepts present in this Python code:\n\nfunction definition, tuple unpacking, list indexing, assert statements, string formatting, arithmetic operations, return statement\n\n### Task", "id": 165808, "sha1": "f35b008f8b8ce16c456068d0066447b71244c41b", "seed": "def actionIndexTuple2Int(actionIdxTuple, numActionList):\n  \"\"\"Transforms tuple of action indices to an action index.\n\n  Args:\n      actionIdxTuple (tuple of int): indices of the Q-matrix.\n      numActionList (list): consists of the number of actions in evader and\n          pursuer's action sets.\n\n  Returns:\n      int: action index of the discrete action set.\n  \"\"\"\n  rowIdx, colIdx = actionIdxTuple\n  assert (\n      rowIdx < numActionList[0]\n  ), \"The size of evader's action set is {:d} but get index {:d}\".format(\n      numActionList[0], rowIdx\n  )\n  assert (\n      colIdx < numActionList[1]\n  ), \"The size of pursuer's action set is {:d} but get index {:d}\".format(\n      numActionList[1], colIdx\n  )\n\n  actionIdx = numActionList[1] * rowIdx + colIdx\n  return actionIdx", "concepts": ["This snippet is not written in Dafny", "but rather in Python. It doesn't contain Dafny-specific concepts or formal verification principles. However", "I can provide a list of general programming concepts present in this Python code:\n\nfunction definition", "tuple unpacking", "list indexing", "assert statements", "string formatting", "arithmetic operations", "return statement"], "instruction": "I understand that you're looking for Dafny programming tasks that focus on verification and formal methods. I'll create a series of tasks that meet your criteria, incorporating formal verification concepts naturally. Here are several tasks:\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: function specification, preconditions, postconditions, mathematical functions\n\n### Task\nImplement a function that computes the absolute value of an integer. Ensure that your implementation is provably correct for all possible integer inputs.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: loop invariants, array manipulation, method specification, termination\n\n### Task\nImplement a method that reverses an array in-place. Your implementation should include appropriate specifications and loop invariants to prove correctness and termination.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, abstraction functions, dynamic frames, two-state invariants\n\n### Task\nDesign and implement a bounded queue data structure using an array. The queue should support enqueue and dequeue operations, and maintain its internal consistency. Prove that all operations preserve the queue's invariants.\n\n## Task 4\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: recursive functions, termination metrics, function specification\n\n### Task\nImplement a recursive function to compute the greatest common divisor (GCD) of two non-negative integers using the Euclidean algorithm. Prove that your function always terminates and returns the correct result.\n\n## Task 5\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: loop invariants, modifies clauses, framing, ghost variables\n\n### Task\nImplement a method that sorts an array using the quicksort algorithm. Prove that your implementation correctly sorts the array and terminates for all inputs.\n\n## Task 6\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: modular verification, method calls, preconditions and postconditions\n\n### Task\nImplement a program that finds the maximum element in an array by dividing it into two halves, finding the maximum in each half recursively, and then comparing the results. Prove the correctness of your implementation using modular verification techniques.\n\n## Task 7\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: function specification, mathematical sequences, quantifiers\n\n### Task\nImplement a function that determines whether a given sequence of integers is palindromic (reads the same forwards and backwards). Prove that your function correctly identifies palindromes for all possible input sequences.\n\nThese tasks cover a range of difficulties and verification concepts in Dafny, encouraging logical thinking and formal reasoning without explicitly stating which verification features to use."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Python\ndifficulty: medium\nconcepts: This snippet is not Dafny code, but rather Python code. It doesn't contain any Dafny-specific concepts or formal verification principles. Therefore, I cannot extract Dafny-related concepts from this snippet.\n\n### Task", "id": 533341, "sha1": "c2ab70d6100ff7ee18de97027618a6cad3fe9fe6", "seed": "def in_box(x, y, box_lims):\n    \"\"\"check if an x, y position falls within a set of limits\n    \n    Args:\n        x: first index\n        y: second index\n        box_lims: [[x low,x high], [y low,y high]]\n    Returns: True if (x,y) is in box_lims, otherwise False \n    \n    \"\"\"\n    if x > box_lims[0, 0] and y > box_lims[1, 0]:\n        if x < box_lims[0, 1] and y < box_lims[1, 1]:\n            return True\n    return False", "concepts": ["This snippet is not Dafny code", "but rather Python code. It doesn't contain any Dafny-specific concepts or formal verification principles. Therefore", "I cannot extract Dafny-related concepts from this snippet."], "instruction": "I understand that you want me to create a series of original Dafny programming tasks that focus on verification. I'll provide several tasks that meet your criteria, excluding the Python example you provided. Here are the tasks:\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: recursive functions, function specification, natural numbers, arithmetic\n\n### Task\nImplement a recursive function in Dafny that calculates the sum of the first n natural numbers. Ensure that your function is properly specified and that Dafny can verify its correctness for all valid inputs.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: array manipulation, loop invariants, method specification, preconditions and postconditions\n\n### Task\nImplement a method in Dafny that reverses an array in-place. The method should take an array of integers as input and modify it so that its elements are in reverse order. Include appropriate specifications and loop invariants to prove the correctness of your implementation.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, dynamic frames, method contracts, abstraction functions, representation invariants\n\n### Task\nDesign and implement a Stack class in Dafny using a dynamic array as the underlying data structure. The class should include methods for push, pop, and peek operations, as well as a property to get the current size of the stack. Ensure that your implementation maintains appropriate class invariants and uses dynamic frames to handle the changing size of the underlying array.\n\n## Task 4\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: recursive methods, method specification, preconditions and postconditions, inductive reasoning\n\n### Task\nImplement a recursive method in Dafny that determines whether a given string is a palindrome. The method should ignore spaces and be case-insensitive. Include proper specifications to prove the correctness of your implementation for all possible inputs.\n\n## Task 5\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: higher-order functions, function specification, lambda expressions, quantifiers\n\n### Task\nImplement a higher-order function in Dafny that takes a predicate (a function that returns a boolean) and an array, and returns a new array containing only the elements that satisfy the predicate. Ensure that your implementation is properly specified and that Dafny can verify its correctness.\n\n## Task 6\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: concurrent programming, thread safety, locks, invariants, ghost variables\n\n### Task\nImplement a thread-safe bounded buffer in Dafny using monitors or locks. The buffer should support concurrent producers and consumers, ensuring that producers cannot add to a full buffer and consumers cannot remove from an empty buffer. Use ghost variables and invariants to prove the correctness and thread-safety of your implementation."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Python\ndifficulty: hard\nconcepts: This snippet is not written in Dafny, but in Python. It doesn't contain any Dafny-specific concepts or formal verification principles. The key programming concepts in this Python code are:\n\nfile I/O, serialization, error handling, function definition, docstring documentation\n\n### Task", "id": 235846, "sha1": "15edac1e406e628bc16124bdf62209a5b458b31c", "seed": "import pickle\n\n\ndef load_obj(path):\n    \"\"\"\n    Load dumped path and return object\n\n    Args:\n        path (string): path with dump\n    \"\"\"\n    with open(path, \"rb\") as fp:\n        return pickle.load(fp)", "concepts": ["This snippet is not written in Dafny", "but in Python. It doesn't contain any Dafny-specific concepts or formal verification principles. The key programming concepts in this Python code are:\n\nfile I/O", "serialization", "error handling", "function definition", "docstring documentation"], "instruction": "I understand that you're looking for Dafny programming tasks that focus on formal verification. I'll create a series of tasks that meet your criteria, incorporating verification concepts naturally without explicitly stating which features to use. Here are several tasks:\n\n## Task 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: integer arithmetic, method specification, postconditions, preconditions\n\n### Task\nImplement a method called `AbsoluteDifference` that takes two integers as input and returns their absolute difference. Ensure that your implementation is correct for all possible integer inputs, including negative numbers and zero.\n\n## Task 2\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: recursion, function specification, preconditions, postconditions, termination\n\n### Task\nImplement a recursive function `FastPower` that calculates the result of raising a base to an exponent efficiently. The function should take two parameters: `base` (an integer) and `exponent` (a non-negative integer). Prove that your implementation is correct and terminates for all valid inputs.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, method framing, object state, dynamic allocation, quantifiers\n\n### Task\nImplement a `PriorityQueue` class that maintains a list of integer elements in descending order. Include methods for inserting an element, removing the maximum element, and checking if the queue is empty. Ensure that the class invariant is maintained throughout all operations and that your implementation is memory-safe.\n\n## Task 4\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: array manipulation, loop invariants, method specification, postconditions\n\n### Task\nImplement a method `RotateArray` that rotates the elements of an array to the right by a given number of positions. For example, rotating the array [1, 2, 3, 4, 5] by 2 positions should result in [4, 5, 1, 2, 3]. Prove that your implementation correctly rotates the array for any valid input.\n\n## Task 5\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: recursion, function specification, preconditions, postconditions, termination, induction\n\n### Task\nImplement a function `LongestCommonSubsequence` that takes two sequences of integers as input and returns the length of their longest common subsequence. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Prove the correctness of your implementation for all possible inputs.\n\n## Task 6\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: method calls, program-level specification, modular verification, preconditions, postconditions\n\n### Task\nImplement a program that simulates a simple bank account system. Include methods for depositing money, withdrawing money, and checking the balance. Ensure that the account balance never becomes negative and that all operations are performed correctly. Prove the correctness of your implementation using appropriate specifications and assertions."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Python\ndifficulty: easy\nconcepts: For this Dafny code snippet, there are no Dafny-specific concepts or formal verification principles to extract. The provided code appears to be Python, not Dafny. Dafny code would include specific verification constructs and syntax that are not present in this snippet.\n\n### Task", "id": 324574, "sha1": "4e227eb4f8df77a4e69182961c55acaecacfd2fb", "seed": "def _level3partition(A, j, k):\n    \"\"\"Return views into A used by the blocked algorithms\"\"\"\n    # Top left corner of diagonal block is [j,j]\n    # Block size is NB = (k-j)\n    R = A[j:k, :j]     # Row block                     /      \\\n    D = A[j:k, j:k]    # triangular block on Diagonal  |      |\n    B = A[k:, :j]      # Big corner block              | R D  |\n    C = A[k:, j:k]     # Column block                  \\ B C  /\n    return R, D, B, C", "concepts": ["For this Dafny code snippet", "there are no Dafny-specific concepts or formal verification principles to extract. The provided code appears to be Python", "not Dafny. Dafny code would include specific verification constructs and syntax that are not present in this snippet."], "instruction": "I understand. I'll create a series of Dafny programming tasks that meet the specified criteria, focusing on formal verification concepts and Dafny-specific features. Here are several tasks:\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: function specification, preconditions, postconditions, mathematical functions\n\n### Task\nImplement a function in Dafny that computes the absolute value of an integer. Ensure your implementation is correct for all possible integer inputs, including minimum and maximum values. Provide appropriate function specifications to prove the correctness of your implementation.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: loop invariants, termination, array manipulation, method specification\n\n### Task\nImplement a method in Dafny that reverses an array of integers in-place. Your method should modify the input array directly without using additional storage. Include proper specifications and loop invariants to prove that your implementation correctly reverses the array and terminates for all inputs.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, dynamic frames, two-state invariants, method contracts\n\n### Task\nDesign and implement a Stack class in Dafny with push, pop, and peek operations. The stack should have a maximum capacity. Use class invariants to ensure the stack's properties are maintained, and implement proper method contracts. Prove that your implementation preserves the stack's integrity across all operations.\n\n## Task 4\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: recursive functions, termination metrics, function specification\n\n### Task\nImplement a recursive function in Dafny that computes the greatest common divisor (GCD) of two non-negative integers using the Euclidean algorithm. Provide appropriate function specifications and a termination metric to prove that your implementation is correct and always terminates.\n\n## Task 5\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: program-level specification, modular verification, ghost variables, lemmas\n\n### Task\nImplement a program in Dafny that finds the longest increasing subsequence in an array of integers. Your solution should include a main method that demonstrates the functionality, along with helper methods or functions as needed. Use ghost variables and lemmas to assist in proving the correctness of your implementation. Ensure that your program specification captures the essence of the longest increasing subsequence problem."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Python\ndifficulty: medium\nconcepts: For the given Python snippet, there are no Dafny-specific concepts or formal verification principles present. This code doesn't contain any Dafny or formal verification elements. It's a standard Python function for joining rows from two lists.\n\n### Task", "id": 219475, "sha1": "0d414e66e9959250b88f5419355616d128759bd5", "seed": "def join_rows(row_list_1, row_list_2):\n    \"\"\"Returns a list of list, in which element is the concatenation of the \n    elements in the same position of row_list1 and row_list.\"\"\"\n    \n    if not row_list_1:\n        return row_list_2\n    if not row_list_2:\n        return row_list_1\n    row_list = []\n    for (row1, row2) in zip(row_list_1, row_list_2):\n        row_list.append(row1+row2)\n    return row_list", "concepts": ["For the given Python snippet", "there are no Dafny-specific concepts or formal verification principles present. This code doesn't contain any Dafny or formal verification elements. It's a standard Python function for joining rows from two lists."], "instruction": "I understand that you're looking for Dafny programming tasks that focus on verification. I'll create a series of tasks that meet your criteria, incorporating formal verification concepts naturally. Here are several tasks:\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: recursive functions, function specification, preconditions and postconditions\n\n### Task\nImplement a recursive function in Dafny that calculates the sum of the first n natural numbers. Ensure your function is properly specified with preconditions and postconditions to guarantee correctness for all valid inputs.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: array manipulation, loop invariants, method specification, modifies clause\n\n### Task\nImplement a method in Dafny that reverses an array in-place. Your method should modify the input array directly, rather than creating a new array. Include appropriate specifications and loop invariants to prove that the array is correctly reversed for any input.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, abstraction functions, dynamic frames, two-state invariants\n\n### Task\nDesign and implement a priority queue class in Dafny using a heap-based data structure. Your class should include methods for insertion, deletion of the minimum element, and peeking at the minimum element. Ensure that your implementation maintains the heap property and uses appropriate abstraction to hide the internal representation.\n\n## Task 4\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: ghost variables, loop invariants, termination metrics\n\n### Task\nImplement a method in Dafny that computes the greatest common divisor (GCD) of two non-negative integers using the Euclidean algorithm. Use ghost variables and loop invariants to prove the correctness of your implementation, and include a termination metric to prove that the method always terminates.\n\n## Task 5\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: inductive proofs, recursive functions, lemmas\n\n### Task\nImplement a function in Dafny that determines whether a given string is a palindrome. Then, write and prove a lemma stating that if a string is a palindrome, then any substring that includes the center of the string is also a palindrome. Use induction in your proof.\n\n## Task 6\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: concurrent programming, atomic operations, invariants in concurrent systems\n\n### Task\nImplement a simple concurrent counter in Dafny that can be safely incremented by multiple threads. Your implementation should use atomic operations to ensure thread safety. Prove that your implementation maintains the correct count regardless of the interleaving of thread operations.\n\nThese tasks cover a range of difficulties and concepts in Dafny, focusing on formal verification without explicitly stating which features to use. They encourage logical thinking and formal reasoning in their solutions."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Python\ndifficulty: medium\nconcepts: For the given Dafny code snippet, here are the key programming concepts extracted, focusing on Dafny-specific concepts and formal verification principles:\n\nmethod declaration, preconditions, postconditions, array manipulation, loop invariants, quantifiers, binary search algorithm, integer arithmetic, conditional statements, return statements, method specification, formal verification, array bounds checking, sorted array property, completeness specification, correctness specification\n\n### Task", "id": 81575, "sha1": "7d5eb4016d6a12ba12a343bbf02c37d4029e65f2", "seed": "def find_net_from_node(node, in_dict, in_keys):\n    \"\"\"\n    Return the net name to which the given node is attached. \n    If it doesn't exist, return None\n    \"\"\"\n    for k in in_keys:\n        if node in in_dict[k]:\n            return k", "concepts": ["For the given Dafny code snippet", "here are the key programming concepts extracted", "focusing on Dafny-specific concepts and formal verification principles:\n\nmethod declaration", "preconditions", "postconditions", "array manipulation", "loop invariants", "quantifiers", "binary search algorithm", "integer arithmetic", "conditional statements", "return statements", "method specification", "formal verification", "array bounds checking", "sorted array property", "completeness specification", "correctness specification"], "instruction": "Certainly! I'll create a series of independent Dafny programming tasks that meet your criteria. Each task will be original, distinct, diverse, and verification-focused, incorporating formal verification concepts naturally.\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: recursive functions, mathematical induction, function specification, preconditions and postconditions\n\n### Task\nImplement a recursive function in Dafny that calculates the sum of the first n positive integers. Ensure your function is properly specified and can be verified to always terminate and produce the correct result.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: loop invariants, array manipulation, method specification, postconditions, quantifiers\n\n### Task\nImplement a method in Dafny that reverses an array in-place. Your method should take an array of integers as input and modify it to contain the elements in reverse order. Prove that your implementation correctly reverses the array for any input.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, dynamic frames, method contracts, abstraction functions, representation invariants\n\n### Task\nImplement a priority queue class in Dafny using a binary heap. Your class should include methods for inserting elements, extracting the minimum element, and decreasing the key of an element. Prove that your implementation maintains the heap property and correctly manages the priority queue operations.\n\n## Task 4\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: loop invariants, modular arithmetic, method specification, preconditions and postconditions\n\n### Task\nImplement a method in Dafny that computes the modular exponentiation (a^b mod m) efficiently. Your method should work for large values of a, b, and m without overflowing. Prove the correctness of your implementation and ensure it terminates for all valid inputs.\n\n## Task 5\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: recursive functions, function specification, preconditions and postconditions, mathematical induction\n\n### Task\nImplement a recursive function in Dafny that determines whether a given string is a palindrome. Your function should ignore spaces and be case-insensitive. Prove that your implementation correctly identifies palindromes for any input string.\n\n## Task 6\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: ghost variables, loop invariants, method contracts, program verification, termination proofs\n\n### Task\nImplement the merge sort algorithm in Dafny. Your program should include a method to merge two sorted arrays and a method to recursively sort an array using the merge method. Prove the correctness of your implementation, including that the resulting array is sorted and contains all elements from the input array.\n\n## Task 7\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: loop invariants, bitvector operations, method specification, preconditions and postconditions\n\n### Task\nImplement a method in Dafny that counts the number of set bits (1s) in the binary representation of a given non-negative integer. Your method should use bitwise operations for efficiency. Prove the correctness of your implementation for all valid inputs.\n\nThese tasks cover a range of difficulties and concepts in Dafny, focusing on formal verification and encouraging logical thinking and formal reasoning. They naturally incorporate verification concepts without explicitly stating which features to use, allowing for creative problem-solving within the Dafny framework."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Python\ndifficulty: hard\nconcepts: This snippet is not in Dafny, but rather in Python. It doesn't contain Dafny-specific concepts or formal verification principles. For Dafny-related concepts, we need a Dafny code snippet.\n\n### Task", "id": 444447, "sha1": "cc029e11d2de9c2ccedb4e60fbf030478468d9a9", "seed": "def compare_fields(lhs, rhs):\n    \"\"\"\n    Comparison function for cpe fields for ordering\n    - * is considered least specific and any non-* value is considered greater\n    - if both sides are non-*, comparison defaults to python lexicographic comparison for consistency\n    \"\"\"\n\n    if lhs == \"*\":\n        if rhs == \"*\":\n            return 0\n        else:\n            return 1\n    else:\n        if rhs == \"*\":\n            return -1\n        else:\n            # case where both are not *, i.e. some value. pick a way to compare them, using lexicographic comparison for now\n            if rhs == lhs:\n                return 0\n            elif rhs > lhs:\n                return 1\n            else:\n                return -1", "concepts": ["This snippet is not in Dafny", "but rather in Python. It doesn't contain Dafny-specific concepts or formal verification principles. For Dafny-related concepts", "we need a Dafny code snippet."], "instruction": "I understand. I'll create a series of Dafny programming tasks that meet the specified criteria, focusing on formal verification concepts and Dafny-specific features. Here are three distinct tasks:\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: recursive functions, function specification, natural numbers, arithmetic operations\n\n### Task\nImplement a recursive function in Dafny that calculates the sum of the first n natural numbers (1 + 2 + ... + n). Ensure that your function is properly specified and that Dafny can verify its correctness for all valid inputs.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: arrays, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a method in Dafny that reverses an array in-place. The method should take an array of integers as input and modify it so that the elements are in reverse order. Include appropriate specifications and loop invariants to prove the correctness of your implementation.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, dynamic frames, method contracts, abstraction functions, representation invariants\n\n### Task\nDesign and implement a Stack class in Dafny using a dynamic array as the underlying data structure. The class should include methods for push, pop, and peek operations, as well as a property to get the current size of the stack. Ensure that your implementation maintains appropriate class invariants and uses dynamic frames to handle the changing size of the internal array. Provide complete specifications for all methods and prove that they maintain the class invariants."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Python\ndifficulty: easy\nconcepts: For this Python code snippet, there are no Dafny-specific concepts or formal verification principles present. The code is a standard Python function without any formal verification constructs. Therefore, I cannot extract any relevant Dafny or formal verification concepts from this snippet.\n\n### Task", "id": 663783, "sha1": "5a94908adfba9ba3e0c82598c3be2b739ec99f2c", "seed": "def batch_split(batch_size, max_num):\n    \"\"\"Split into equal parts of {batch_size} as well as the tail\"\"\"\n\n    if batch_size > max_num:\n        print(\"Fix the batch size to maximum number.\")\n        batch_size = max_num\n\n    max_range = list(range(max_num))\n    num_splits = max_num // batch_size\n    num_splits = (\n        num_splits - 1 if max_num % batch_size == 0 else num_splits\n    )  # for edge case, there will be an empty batch\n    splits = []\n    for i in range(num_splits + 1):\n        start = i * batch_size\n        end = min((i + 1) * batch_size, max_num)  # dealing the tail part\n        splits.append(max_range[start:end])\n    assert len(splits) == num_splits + 1\n    return splits", "concepts": ["For this Python code snippet", "there are no Dafny-specific concepts or formal verification principles present. The code is a standard Python function without any formal verification constructs. Therefore", "I cannot extract any relevant Dafny or formal verification concepts from this snippet."], "instruction": "I understand that you're looking for Dafny programming tasks that focus on verification. I'll create a series of tasks that meet your criteria, incorporating formal verification concepts naturally. Here are several tasks:\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: function specification, preconditions, postconditions, mathematical functions\n\n### Task\nImplement a function `Factorial(n: nat): nat` that computes the factorial of a given natural number. Ensure that your implementation is correct for all valid inputs, including edge cases.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: loop invariants, array manipulation, method specification, termination\n\n### Task\nImplement a method `ReverseArray(arr: array<int>)` that reverses the elements of an integer array in-place. Prove that your implementation correctly reverses the array and terminates for all inputs.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, abstraction functions, data structure representation\n\n### Task\nImplement a `Stack<T>` class with `Push`, `Pop`, and `Peek` operations. Use an array as the underlying data structure. Ensure that your implementation maintains proper stack behavior and preserves the class invariant across all operations.\n\n## Task 4\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: recursive functions, inductive proofs, function specification\n\n### Task\nImplement a recursive function `IsPalindrome(s: string): bool` that determines whether a given string is a palindrome. Prove the correctness of your implementation for all possible input strings.\n\n## Task 5\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: two-state invariants, object mutation, framing, method specification\n\n### Task\nImplement a method `MergeSort(arr: array<int>)` that sorts an array using the merge sort algorithm. Prove that your implementation correctly sorts the array and does not modify any elements outside the given array.\n\n## Task 6\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: modular verification, program composition, method calls, postcondition strengthening\n\n### Task\nImplement a program that finds the maximum sum of any contiguous subarray within a given array of integers. Break down the problem into smaller methods or functions, and ensure that each component is verified independently before composing them into the final solution.\n\n## Task 7\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: function specification, preconditions, postconditions, mathematical properties\n\n### Task\nImplement a function `GCD(a: nat, b: nat): nat` that computes the greatest common divisor of two natural numbers using the Euclidean algorithm. Prove that your implementation correctly calculates the GCD for all valid inputs."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Python\ndifficulty: medium\nconcepts: recursive function, tree traversal, string formatting, conditional logic\n\n### Task", "id": 203341, "sha1": "0eb7c9940f38acc0cd148a8b54c99d9cd1e8cfb1", "seed": "def generate_tree(node):\n    \"\"\"\n    Generates the string representation of the parse tree.\n    :param nodes: the root node.\n    :return: the parse tree in string form.\n    \"\"\"\n    if node.child2 == None:\n        return f\"[{node.symbol} '{node.child1}']\"\n    else:\n        return f\"[{node.symbol} {generate_tree(node.child1)} {generate_tree(node.child2)}]\"", "concepts": ["recursive function", "tree traversal", "string formatting", "conditional logic"], "instruction": "I understand that you're looking for Dafny programming tasks, not Python tasks. I'll provide a series of Dafny tasks that meet your criteria. Here are three diverse, verification-focused Dafny programming tasks:\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: recursive function, mathematical induction, function specification, preconditions and postconditions\n\n### Task\nImplement a recursive function in Dafny that calculates the sum of the first n positive integers. The function should take a non-negative integer n as input and return the sum 1 + 2 + ... + n. Include appropriate specifications to prove the correctness of your implementation, considering both the base case and the inductive step.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a method in Dafny that reverses an array in-place. The method should take an array of integers as input and modify it so that the elements are in reverse order. Include proper specifications and loop invariants to prove that the method correctly reverses the array and maintains all original elements.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: data structure invariants, class invariants, method contracts, abstraction functions, representation invariants\n\n### Task\nImplement a priority queue class in Dafny using a binary heap. The class should support the following operations: insert an element, remove the minimum element, and peek at the minimum element. Implement the binary heap using an array. Define appropriate class invariants, abstraction functions, and representation invariants to prove the correctness of your implementation. Ensure that all methods maintain the heap property and that the array is always a valid representation of a binary heap."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Python\ndifficulty: easy\nconcepts: For the given Python snippet, there are no Dafny-specific concepts or formal verification principles present. The code is a standard Python function without any verification constructs. Therefore, I cannot extract any relevant Dafny or formal verification concepts from this snippet.\n\n### Task", "id": 348373, "sha1": "d6bd365dcc69a4036248171931422b19c52c1745", "seed": "import math\n\n\ndef _get_num_combos(n: int, r: int):\n    \"\"\"Return number of combinations.\n\n    Parameters\n    ----------\n    n : int\n        Number to choose from\n    r : int\n        Number to choose\n\n    Returns\n    -------\n        Number of combinations\n    \"\"\"\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))", "concepts": ["For the given Python snippet", "there are no Dafny-specific concepts or formal verification principles present. The code is a standard Python function without any verification constructs. Therefore", "I cannot extract any relevant Dafny or formal verification concepts from this snippet."], "instruction": "Understood. I'll create a series of original Dafny programming tasks that focus on verification and incorporate formal reasoning concepts. Here are the tasks:\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: recursive functions, function specification, preconditions and postconditions, inductive reasoning\n\n### Task\nImplement a recursive function in Dafny that calculates the sum of the first n positive integers. Provide appropriate function specifications to ensure correctness for all non-negative integer inputs.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: loop invariants, array manipulation, method specification, postconditions, quantifiers\n\n### Task\nImplement a method in Dafny that reverses the elements of an array in-place. The method should modify the input array directly without using additional storage. Include proper specifications and loop invariants to prove the correctness of your implementation.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, abstraction functions, dynamic frames, method specifications, ghost variables\n\n### Task\nDesign and implement a priority queue class in Dafny using a binary heap. The class should support insert and extractMax operations. Use appropriate class invariants, abstraction functions, and dynamic frames to ensure the correctness of your implementation.\n\n## Task 4\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: recursive functions, function specification, preconditions and postconditions, inductive reasoning, algebraic datatypes\n\n### Task\nImplement a recursive function in Dafny that determines whether a binary tree (represented as an algebraic datatype) is balanced. A binary tree is considered balanced if the heights of the left and right subtrees of every node differ by at most one. Include appropriate function specifications to prove the correctness of your implementation.\n\n## Task 5\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: loop invariants, method specification, preconditions and postconditions, quantifiers, modular arithmetic\n\n### Task\nImplement a method in Dafny that computes the modular exponentiation (a^b mod m) efficiently using the square-and-multiply algorithm. The method should work for large positive integers. Include proper specifications and loop invariants to prove the correctness and efficiency of your implementation."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Python\ndifficulty: hard\nconcepts: For the given Python snippet, there are no Dafny-specific concepts or formal verification principles present. The code is a standard Python function definition without any formal verification constructs. Therefore, I cannot provide a list of Dafny-related concepts for this snippet.\n\n### Task", "id": 488041, "sha1": "3edda847b270f1d013c9cb06731d220d7d629081", "seed": "def update_at_index(idx, new_value):\n    \"\"\"Helper function to modify list in-place, setting value at idx to new_value.\n    for use in pandas apply and applymap, eg x.apply(update_at_index(0, \"A\")).\"\"\"\n    def updater(mylist):\n        mylist[idx] = new_value\n    return updater", "concepts": ["For the given Python snippet", "there are no Dafny-specific concepts or formal verification principles present. The code is a standard Python function definition without any formal verification constructs. Therefore", "I cannot provide a list of Dafny-related concepts for this snippet."], "instruction": "I understand that you want me to create a series of original Dafny programming tasks focused on verification. I'll provide several tasks that meet your criteria, incorporating formal verification concepts naturally without explicitly stating which features to use.\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: recursive functions, function specification, preconditions and postconditions, natural numbers\n\n### Task\nImplement a recursive function in Dafny that calculates the sum of the first n natural numbers. Ensure that your function is properly specified and that Dafny can verify its correctness for all valid inputs.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: loop invariants, array manipulation, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a method in Dafny that reverses an array in-place. Your method should take an array as input and modify it to contain the elements in reverse order. Include appropriate specifications and loop invariants to prove the correctness of your implementation.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, dynamic frames, method specifications, abstraction functions, ghost variables\n\n### Task\nImplement a priority queue class in Dafny using a binary heap. Your class should include methods for inserting elements, removing the minimum element, and peeking at the minimum element. Ensure that your implementation maintains the heap property and that all operations are verified to be correct.\n\n## Task 4\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: recursive functions, function specification, preconditions and postconditions, natural numbers, modular arithmetic\n\n### Task\nImplement a recursive function in Dafny that computes the n-th Fibonacci number modulo a given positive integer m. Your function should be efficient and avoid integer overflow. Include appropriate specifications to prove the correctness of your implementation.\n\n## Task 5\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: loop invariants, array manipulation, method specification, preconditions and postconditions, quantifiers, sorting algorithms\n\n### Task\nImplement the merge step of the merge sort algorithm in Dafny. Your method should take two sorted subarrays within a larger array and merge them into a single sorted subarray. Include proper specifications and loop invariants to prove the correctness of your implementation.\n\n## Task 6\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: method specifications, preconditions and postconditions, loop invariants, termination, integer arithmetic\n\n### Task\nImplement a program in Dafny that finds the greatest common divisor (GCD) of two non-negative integers using the Euclidean algorithm. Your program should include a method that computes the GCD and a main method that demonstrates its usage. Ensure that your implementation is verified to be correct and terminates for all valid inputs."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Python\ndifficulty: easy\nconcepts: For this Python snippet, there are no Dafny-specific concepts or formal verification principles to extract. The code is a Python function definition with a docstring and list comprehension. It doesn't contain any Dafny or formal verification elements.\n\n### Task", "id": 664621, "sha1": "10fe03ab2ddb1a5602e816dac398e6ce57fca082", "seed": "def int_list_to_string(intli, sep=''):\n    \"\"\"\u6574\u6570\u5217\u8868\u8f6c\u5b57\u7b26\u4e32\n    :param intli:\n    :param sep:\n    :return:\n    >>> int_list_to_string([1,2])\n    '\\\\x01\\\\x02'\n    \"\"\"\n    return sep.join([chr(n) for n in intli])", "concepts": ["For this Python snippet", "there are no Dafny-specific concepts or formal verification principles to extract. The code is a Python function definition with a docstring and list comprehension. It doesn't contain any Dafny or formal verification elements."], "instruction": "Understood. I'll create a series of original Dafny programming tasks that focus on verification and incorporate formal reasoning concepts. Here are five diverse tasks:\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: recursive functions, function specification, preconditions and postconditions, natural numbers\n\n### Task\nImplement a recursive function in Dafny that calculates the sum of the first n natural numbers. The function should take a natural number n as input and return the sum 1 + 2 + ... + n. Include appropriate function specifications to ensure correctness and termination.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a method in Dafny that reverses an array in-place. The method should take an array of integers as input and modify it so that its elements are in reverse order. Provide proper specifications and loop invariants to prove the correctness of your implementation.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, dynamic frames, abstraction functions, ghost variables, two-state predicates\n\n### Task\nDesign and implement a Stack class in Dafny using a dynamic array. The class should include methods for push, pop, and peek operations, as well as a property to check if the stack is empty. Use appropriate class invariants, abstraction functions, and ghost variables to maintain the stack's integrity and prove the correctness of operations.\n\n## Task 4\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: mathematical functions, method specification, preconditions and postconditions, loop invariants, modular arithmetic\n\n### Task\nImplement a method in Dafny that computes the modular exponentiation (a^b mod m) efficiently. The method should take three non-negative integers a, b, and m as input and return the result. Include proper specifications and loop invariants to prove the correctness and efficiency of your implementation.\n\n## Task 5\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: graphs, adjacency list representation, depth-first search, reachability, termination metrics, ghost variables\n\n### Task\nImplement a program in Dafny that determines if there exists a path between two vertices in an undirected graph. Represent the graph using an adjacency list. The program should include a method that takes the graph, a start vertex, and an end vertex as input, and returns a boolean indicating whether a path exists. Use appropriate specifications, ghost variables, and termination metrics to prove the correctness of your implementation."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Python\ndifficulty: medium\nconcepts: For the given Dafny code snippet (Example 1), here are the key programming concepts extracted, focusing on Dafny-specific concepts and formal verification principles:\n\npreconditions, postconditions, loop invariants, array manipulation, quantifiers, method specification, binary search algorithm, formal verification, requires clause, ensures clause, invariant clause, null check, sorted array property, index bounds checking, completeness property, soundness property\n\n### Task", "id": 377054, "sha1": "025f24c09d93c5baef793a49b55677783feee468", "seed": "def extend_pyflow_docstring(docstring):\n\t\"\"\"\n\tUpdates a doc string to include the usage instructions for default pyflow parameters\n\t\"\"\"\n\tdefault_docstring = \"\"\"\n\tPyflow arguments:\n\tOptional arguments:\n\t\t--run_mode   Valid options: (Default) 'local', 'sge'\n\t\t--nCores     Number of threads to use (Default: 1)\n\t\t--memMb      memory available in local mode in MB\n\t\t--mailTo     Email address to send updates on pipeline running progress.\n\t\t--pyflow_dir     Directory to store pyflow tracking data.\n\t\t--dry       Set this flag to run in dry mode (does not launch tasks).\n\t\t--isContinue    Modify the continuation method of pyflow. Default: auto\n\t\t--forceContinue    If isContinue is set, allows task definitions to change.\n\t\t--startFromTasks    A comma-delimited list of task labels as strings. Any tasks which are not in this set or descendants of this set will be marked as completed.\n\t\t--ignoreTasksAfter  A comma-delimited list of task labels as strings. All descendants of these task labels will be ignored.\n\t\t--resetTasks    A comma-delimited list of task labels as strings. These tasks and all of their descendants will be reset to the \"waiting\" state to be re-run. Note this option will only effect a workflow which has been continued from a previous run. This will not overide any nodes alterned by the startFromTasks setting in the case that both options are used together\n\t\t--schedulerArgList A list of additional Parameters related to scheduler\n\t\"\"\"\n\treturn docstring + default_docstring", "concepts": ["For the given Dafny code snippet (Example 1)", "here are the key programming concepts extracted", "focusing on Dafny-specific concepts and formal verification principles:\n\npreconditions", "postconditions", "loop invariants", "array manipulation", "quantifiers", "method specification", "binary search algorithm", "formal verification", "requires clause", "ensures clause", "invariant clause", "null check", "sorted array property", "index bounds checking", "completeness property", "soundness property"], "instruction": "I understand that you're looking for a series of original Dafny programming tasks that focus on verification concepts. I'll create several tasks adhering to the specified properties and incorporating formal verification principles without explicitly stating which features to use. Here are the tasks:\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: recursive functions, natural numbers, function specification, preconditions and postconditions\n\n### Task\nImplement a recursive function in Dafny that calculates the sum of the first n natural numbers. Ensure that your function is properly specified and verified for all valid inputs.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: arrays, in-place reversal, loop invariants, method specification, array manipulation\n\n### Task\nCreate a method that reverses an array in-place. The method should take an array of integers as input and modify it to contain the elements in reverse order. Prove that your implementation correctly reverses the array for any valid input.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: data structures, class invariants, method contracts, abstraction, encapsulation\n\n### Task\nImplement a priority queue class using a binary heap. Include methods for inserting elements, extracting the minimum element, and decreasing the key of an element. Ensure that your implementation maintains the heap property and is verified for all operations.\n\n## Task 4\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: mathematical functions, recursive definitions, function specification, preconditions and postconditions\n\n### Task\nImplement a function that computes the greatest common divisor (GCD) of two non-negative integers using the Euclidean algorithm. Prove that your implementation is correct and terminates for all valid inputs.\n\n## Task 5\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: graph algorithms, depth-first search, recursion, method specification, ghost variables\n\n### Task\nImplement a method that performs a depth-first search on a graph represented as an adjacency list. The method should return a boolean indicating whether there is a path between two given vertices. Prove the correctness of your implementation, including termination and completeness.\n\n## Task 6\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: sorting algorithms, array manipulation, loop invariants, method specification, program verification\n\n### Task\nImplement the insertion sort algorithm as a complete Dafny program. Your implementation should include a method that sorts an array of integers in ascending order. Prove that your implementation correctly sorts the array and maintains its elements.\n\nThese tasks cover a range of difficulties and concepts in Dafny, focusing on formal verification without explicitly stating which features to use. They encourage logical thinking and formal reasoning in their solutions."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Python\ndifficulty: easy\nconcepts: This snippet is not Dafny code, but rather Python code. It doesn't contain any Dafny-specific concepts or formal verification principles. The key concepts in this Python code are:\n\ndictionary comprehension, list manipulation, function definition, docstring\n\n### Task", "id": 633087, "sha1": "83c7445e1c4c2c034f609f19da0d9638b3d9dbf3", "seed": "def __points_to_dict(points):\n    \"\"\"transform list of [x, y] into a dict() where {x: y}\"\"\"\n    return {p[0]: p[1] for p in points}", "concepts": ["This snippet is not Dafny code", "but rather Python code. It doesn't contain any Dafny-specific concepts or formal verification principles. The key concepts in this Python code are:\n\ndictionary comprehension", "list manipulation", "function definition", "docstring"], "instruction": "I understand that you're looking for Dafny programming tasks that focus on verification and formal methods. I'll create a series of tasks that meet your criteria, focusing on Dafny-specific concepts and verification techniques. Here are several tasks for you:\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: function specification, preconditions, postconditions, mathematical functions\n\n### Task\nImplement a function in Dafny that calculates the absolute value of an integer. The function should take an integer as input and return its absolute value. Include appropriate specifications to ensure the correctness of the implementation.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: loop invariants, array manipulation, method specification, termination\n\n### Task\nImplement a method in Dafny that reverses an array of integers in-place. The method should modify the input array directly, without using additional data structures. Ensure that your implementation includes proper specifications and loop invariants to prove correctness.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, dynamic frames, two-state invariants, modifies clauses\n\n### Task\nDesign and implement a Stack class in Dafny that supports push, pop, and peek operations. The class should maintain an internal array to store elements. Include appropriate class invariants, dynamic frames, and two-state invariants to ensure the correctness of the implementation. Prove that the class maintains its invariants across method calls.\n\n## Task 4\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: recursive functions, termination metrics, function specification\n\n### Task\nImplement a recursive function in Dafny that computes the nth Fibonacci number. Include appropriate specifications and a termination metric to prove that the function always terminates and produces the correct result.\n\n## Task 5\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: ghost variables, loop invariants, modifies clauses, quantifiers\n\n### Task\nImplement a method in Dafny that sorts an array of integers using the quicksort algorithm. Use ghost variables to aid in the verification process. Include appropriate loop invariants and modifies clauses to prove the correctness of the implementation. Ensure that the method specification includes a quantifier to express that the output array is sorted.\n\n## Task 6\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: datatype definition, pattern matching, recursive functions, function specification\n\n### Task\nDefine a datatype in Dafny to represent binary trees. Implement a function that computes the height of a binary tree. Then, implement another function that determines if a given binary tree is balanced (i.e., the heights of the left and right subtrees of every node differ by at most one). Use pattern matching and recursion in your implementation, and include appropriate specifications for both functions."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Python\ndifficulty: easy\nconcepts: This snippet is not written in Dafny, but rather in Python. Therefore, I cannot extract Dafny-specific concepts or formal verification principles from it. The provided code is a Python function that handles string formatting and dedentation. It doesn't contain any of the Dafny-specific or formal verification concepts you've asked about.\n\nFor a proper analysis, please provide a Dafny code snippet. Dafny code typically includes verification constructs like requires, ensures, and invariants, as well as other formal specification and proof-related elements.\n\n### Task", "id": 83645, "sha1": "1c8c98aea22c880aed2b2269b4077118b0782ab5", "seed": "from textwrap import dedent\n\n\ndef format_description(string: str, **kwargs) -> str:\n    \"\"\"\n    Remove common leading whitespace from every line in text.\n    Useful for processing triple-quote strings.\n\n    If keyword arguments are supplied, they will serve as arguments for\n    formatting the dedented string using str.format().\n\n    :param string: The string to unwrap\n\n    >>> format_description(\" c'est \\\\n une chaine \\\\n de plusieurs lignes. \")\n    \"c'est \\\\nune chaine \\\\nde plusieurs lignes. \"\n\n    >>> format_description('''\n    ...     Multi-lined,\n    ...     indented,\n    ...     triple-quoted string.\n    ... ''')\n    '\\\\nMulti-lined,\\\\nindented,\\\\ntriple-quoted string.\\\\n'\n\n    >>> format_description('{foo}{bar!r}', foo=123, bar={})\n    '123{}'\n    \"\"\"\n    dedented = dedent(string)\n    return dedented.format(**kwargs) if kwargs else dedented", "concepts": ["This snippet is not written in Dafny", "but rather in Python. Therefore", "I cannot extract Dafny-specific concepts or formal verification principles from it. The provided code is a Python function that handles string formatting and dedentation. It doesn't contain any of the Dafny-specific or formal verification concepts you've asked about.\n\nFor a proper analysis", "please provide a Dafny code snippet. Dafny code typically includes verification constructs like requires", "ensures", "and invariants", "as well as other formal specification and proof-related elements."], "instruction": "I understand. I'll create a series of original Dafny programming tasks that focus on verification and incorporate formal reasoning concepts. Here are three diverse tasks:\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: function specification, preconditions, postconditions, mathematical reasoning\n\n### Task\nImplement a function `IsTriangular(n: nat): bool` that determines whether a given natural number `n` is triangular. A triangular number is a number that can be represented as the sum of consecutive integers from 1 to some k. For example, 6 is triangular (1 + 2 + 3 = 6), but 7 is not.\n\nEnsure your function is properly specified with preconditions and postconditions. Your implementation should allow Dafny to verify its correctness automatically.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: loop invariants, array manipulation, method specification, modifies clause\n\n### Task\nImplement a method `RotateArray(arr: array<int>, k: int)` that rotates the elements of the array to the right by `k` positions. For example, if the input array is `[1, 2, 3, 4, 5]` and `k = 2`, the result should be `[4, 5, 1, 2, 3]`.\n\nYour implementation should use in-place rotation (i.e., modify the original array) and handle cases where `k` is larger than the array length. Include appropriate specifications and loop invariants to prove the correctness of your implementation.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, dynamic frames, ghost variables, abstraction functions, representation predicates\n\n### Task\nImplement a `PriorityQueue` class in Dafny that maintains a list of integer elements in descending order of priority (higher numbers have higher priority). The class should support the following operations:\n\n1. `Enqueue(element: int)`: Add an element to the queue.\n2. `Dequeue(): int`: Remove and return the highest priority element.\n3. `Peek(): int`: Return the highest priority element without removing it.\n4. `Size(): nat`: Return the number of elements in the queue.\n\nUse a sequence as the underlying data structure. Implement the class with proper specifications, including class invariants, abstraction functions, and representation predicates. Ensure that your implementation allows Dafny to verify the correctness of all operations, including maintaining the priority order after each operation."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Python\ndifficulty: easy\nconcepts: This snippet doesn't contain Dafny code or formal verification concepts. It appears to be a Python method. As such, there are no relevant Dafny-specific or formal verification concepts to extract from this code.\n\n### Task", "id": 168341, "sha1": "4f7f9b73a84ce2ed957e2fbf38a1e067e32c902c", "seed": "def get_permalink_url(self):\n    \"\"\"\n    Get a permalink URL\n    \"\"\"\n    return \"/\".join((self.settings[\"SITEURL\"], self.get_permalink_path()))", "concepts": ["This snippet doesn't contain Dafny code or formal verification concepts. It appears to be a Python method. As such", "there are no relevant Dafny-specific or formal verification concepts to extract from this code."], "instruction": "I understand that you want me to create a series of original Dafny programming tasks focused on verification. I'll provide several tasks that meet your criteria, incorporating formal verification concepts naturally without explicitly stating which features to use. Here are the tasks:\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: function specification, preconditions, postconditions, mathematical integers\n\n### Task\nImplement a function that calculates the absolute value of an integer. Ensure that your implementation works correctly for all possible integer inputs, including the minimum possible integer value.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: method specification, loop invariants, array manipulation, quantifiers\n\n### Task\nImplement a method that reverses an array in-place. The method should modify the input array directly without using additional storage. Prove that your implementation correctly reverses the array for any input.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, dynamic frames, abstraction functions, ghost variables\n\n### Task\nDesign and implement a priority queue class using a binary heap. The class should support insertion, extraction of the minimum element, and decrease-key operations. Prove that the heap property is maintained after each operation.\n\n## Task 4\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: termination metrics, well-founded relations, recursive functions\n\n### Task\nImplement the merge sort algorithm as a recursive function. Prove that your implementation always terminates and correctly sorts the input array.\n\n## Task 5\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: method specification, postconditions, mathematical sets\n\n### Task\nImplement a method that takes two arrays as input and returns a new array containing only the elements that appear in both input arrays (i.e., the intersection). Prove that your implementation correctly computes the intersection.\n\n## Task 6\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: function specification, recursive functions, inductive proofs\n\n### Task\nImplement a function that determines whether a given string is a palindrome. The function should work recursively without using loops. Prove the correctness of your implementation for all possible input strings.\n\nThese tasks cover a range of difficulties and concepts in Dafny, focusing on formal verification without explicitly stating which features to use. They encourage logical thinking and formal reasoning in their solutions."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: Python\ndifficulty: medium\nconcepts: For the given Python snippet, there are no Dafny-specific concepts or formal verification principles present. This is a standard Python function without any formal verification constructs. However, I can provide concepts related to the Python code itself:\n\nlist comprehension, zip function, arithmetic operations, function definition, docstring\n\n### Task", "id": 685252, "sha1": "ce93cdeeacd8de5eb1d752300c738212ed84bd25", "seed": "def average_list(l1, l2):\n    \"\"\"Return the average of two lists\"\"\"\n    return [(i1 + i2) / 2 for i1, i2 in zip(l1, l2)]", "concepts": ["For the given Python snippet", "there are no Dafny-specific concepts or formal verification principles present. This is a standard Python function without any formal verification constructs. However", "I can provide concepts related to the Python code itself:\n\nlist comprehension", "zip function", "arithmetic operations", "function definition", "docstring"], "instruction": "I understand that you're looking for Dafny programming tasks that focus on verification. I'll create a series of tasks that meet your criteria, incorporating formal verification concepts naturally. Here are the tasks:\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: recursive functions, function specification, preconditions and postconditions, natural numbers\n\n### Task\nImplement a recursive function in Dafny that calculates the sum of the first n natural numbers. Ensure that your function is properly specified with preconditions and postconditions to guarantee correctness for all valid inputs.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: loop invariants, array manipulation, method specification, modifies clause, termination\n\n### Task\nImplement a method in Dafny that reverses an array in-place. Your implementation should include appropriate loop invariants to prove that the array is correctly reversed. Ensure that your method specification captures the behavior of the reversal operation.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, dynamic frames, method contracts, abstraction functions, representation invariants\n\n### Task\nDesign and implement a Dafny class representing a priority queue using a binary heap. Include methods for insertion, deletion of the minimum element, and peeking at the minimum element. Ensure that your class maintains appropriate invariants and that all methods have proper specifications.\n\n## Task 4\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: ghost variables, lemmas, inductive proofs, quantifiers, algebraic datatypes\n\n### Task\nImplement a program in Dafny that defines an algebraic datatype for binary trees and includes a function to calculate the height of a tree. Write a lemma that proves that the height of a tree is always less than or equal to the number of nodes in the tree, and verify this property for all possible trees.\n\n## Task 5\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: two-state invariants, old expressions, framing, modular verification, method calls\n\n### Task\nImplement a bank account system in Dafny with methods for deposit, withdrawal, and transfer between accounts. Use two-state invariants to ensure that the total balance across all accounts remains constant during transfers. Implement and verify a method that performs a sequence of transfers between multiple accounts.\n\nThese tasks cover a range of Dafny concepts and verification techniques, encouraging logical thinking and formal reasoning without explicitly stating which verification features to use."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Python\ndifficulty: easy\nconcepts: For the given Dafny code snippet, here are the key programming concepts extracted, focusing on Dafny-specific concepts and formal verification principles:\n\nmethod specification, preconditions, postconditions, array manipulation, loop invariants, quantifiers, binary search algorithm, formal verification, requires clause, ensures clause, invariant clause, null check, sorted array property, index bounds checking, result correctness specification, loop-based implementation, midpoint calculation, conditional branching, return value semantics\n\n### Task", "id": 308607, "sha1": "e71011b4ab911714ad4758a54fdc40814c9f65ec", "seed": "def regSortFeatureVersionKey(feature):\n    \"\"\"Sort key for regSortFeatures - key is the feature version.\n    `<extension>` elements all have version number 0.\"\"\"\n\n    return float(feature.versionNumber)", "concepts": ["For the given Dafny code snippet", "here are the key programming concepts extracted", "focusing on Dafny-specific concepts and formal verification principles:\n\nmethod specification", "preconditions", "postconditions", "array manipulation", "loop invariants", "quantifiers", "binary search algorithm", "formal verification", "requires clause", "ensures clause", "invariant clause", "null check", "sorted array property", "index bounds checking", "result correctness specification", "loop-based implementation", "midpoint calculation", "conditional branching", "return value semantics"], "instruction": "Understood. I'll create a series of original, distinct, and diverse Dafny programming tasks that focus on verification concepts. Each task will adhere to the specified properties and encourage logical thinking and formal reasoning.\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: recursive function, preconditions, postconditions, natural numbers, mathematical induction\n\n### Task\nImplement a recursive function in Dafny that calculates the sum of the first n natural numbers (1 + 2 + ... + n). Ensure that your function is properly specified with preconditions and postconditions. Prove that your implementation is correct for all non-negative integers n.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a method in Dafny that reverses an array in-place. The method should take an array of integers as input and modify it so that the elements are in reverse order. Include appropriate specifications and loop invariants to prove the correctness of your implementation.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, dynamic frames, method contracts, abstraction functions, representation invariants\n\n### Task\nImplement a priority queue class in Dafny using a binary heap. The class should support the following operations: insert, extractMax, and peek. Use class invariants to maintain the heap property, and implement appropriate method contracts. Prove that your implementation preserves the heap invariant after each operation.\n\n## Task 4\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: modular arithmetic, loop invariants, method specification, preconditions and postconditions, termination\n\n### Task\nImplement a method in Dafny that computes the modular exponentiation (a^b mod m) efficiently using the square-and-multiply algorithm. Include proper specifications and loop invariants to prove the correctness and termination of your implementation.\n\n## Task 5\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: graph representation, depth-first search, recursion, method specification, preconditions and postconditions, termination\n\n### Task\nImplement a program in Dafny that detects cycles in a directed graph using depth-first search. Represent the graph using an adjacency list. Include a method that determines if the graph contains a cycle and returns a boolean result. Prove the correctness and termination of your implementation.\n\nThese tasks cover a range of difficulties and concepts in Dafny, focusing on formal verification without explicitly stating which features to use. They encourage logical thinking and formal reasoning while exploring various areas of algorithm implementation and data structure design."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: Python\ndifficulty: easy\nconcepts: This snippet is not written in Dafny, but rather in Python. It doesn't contain Dafny-specific concepts or formal verification principles. The key programming concepts for this Python code would be:\n\nrandom number generation, string manipulation, list comprehension, function definition, module import, cryptographically secure operations\n\nFor Dafny-specific concepts and formal verification principles, we would need a Dafny code snippet to analyze.\n\n### Task", "id": 326409, "sha1": "35056b5ffb44577abe077e1d5c0a9ec0b010c1b2", "seed": "import secrets\n\n\ndef generate_password(character_set, length):\n    \"\"\"\n    Uses the secretes module to pick a given number of characters\n    from the available character set. https://docs.python.org/3/library/secrets.html\n    \"\"\"\n    # \"complexity is the worst enemy of security\" - Bruce Schneier.\n    return ''.join(secrets.choice(character_set) for _character in range(length))", "concepts": ["This snippet is not written in Dafny", "but rather in Python. It doesn't contain Dafny-specific concepts or formal verification principles. The key programming concepts for this Python code would be:\n\nrandom number generation", "string manipulation", "list comprehension", "function definition", "module import", "cryptographically secure operations\n\nFor Dafny-specific concepts and formal verification principles", "we would need a Dafny code snippet to analyze."], "instruction": "I understand that you're looking for original, distinct, and diverse Dafny programming tasks that focus on verification. I'll create a series of tasks that incorporate formal verification concepts naturally, without explicitly stating which features to use. Here are several tasks that meet your criteria:\n\n## Task 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: method specification, postconditions, arithmetic operations, modular arithmetic\n\n### Task\nImplement a method called `IsLeapYear` that takes an integer year as input and returns a boolean indicating whether the year is a leap year. A leap year is divisible by 4, but century years are leap years only if they are divisible by 400. Ensure your implementation is correct for any given year.\n\n## Task 2\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: recursive functions, function specification, preconditions, postconditions, natural number properties\n\n### Task\nImplement a recursive function `Ackermann(m: nat, n: nat): nat` that computes the Ackermann function. The Ackermann function is defined as follows:\n- A(0, n) = n + 1\n- A(m + 1, 0) = A(m, 1)\n- A(m + 1, n + 1) = A(m, A(m + 1, n))\nEnsure that your implementation terminates for all valid inputs and produces the correct result.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: class invariants, method contracts, dynamic frames, object state\n\n### Task\nImplement a `Stack` class that represents a generic stack data structure. Include methods for push, pop, and peek operations, as well as a property to check if the stack is empty. Ensure that the class maintains its internal consistency and that all operations behave correctly, even in edge cases.\n\n## Task 4\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: loop invariants, termination, array manipulation, quantifiers, ghost variables\n\n### Task\nImplement a program that sorts an array of integers using the quicksort algorithm. Your implementation should include the main quicksort method and a partition method. Prove that your implementation correctly sorts the input array and terminates for all possible inputs.\n\n## Task 5\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: bitvector operations, method specification, postconditions, preconditions\n\n### Task\nImplement a method `CountSetBits(x: bv32): nat` that counts the number of set bits (1s) in a 32-bit bitvector. Your implementation should be efficient and provably correct for all possible inputs.\n\n## Task 6\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: recursive functions, inductive proofs, function specification, natural number properties\n\n### Task\nImplement a recursive function `IsPrime(n: nat): bool` that determines whether a given natural number is prime. Additionally, prove that your implementation is correct for all natural numbers. Consider using helper lemmas to structure your proof.\n\nThese tasks cover a range of difficulties and concepts in Dafny, focusing on formal verification without explicitly stating which features to use. They encourage logical thinking and formal reasoning in their solutions."}
{"prompt": "Create a series of independent Dafny programming tasks that are original, distinct, diverse, and verification-focused. Each task must adhere to specified properties:\n\n- category: the type of task (method implementation, function implementation, class implementation, or program implementation)\n- language: Dafny\n- difficulty: the complexity level (easy, medium, or hard)\n- concepts: fundamental verification principles and techniques required for the solution\n\nDesign tasks that naturally incorporate formal verification concepts without explicitly stating which verification features to use. Tasks should encourage logical thinking and formal reasoning.\n\n## Example 1\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: binary search algorithm, array manipulation, loop invariants, method specification, preconditions and postconditions, quantifiers\n\n### Task\nImplement a binary search method in Dafny that searches for a key in a sorted array. The method should return the index of the key if found, or -1 if not found. Include proper specifications (requires and ensures clauses) and loop invariants to prove the correctness of the implementation.\n\n## Example 2\n### Properties\ncategory: program implementation\nlanguage: Python\ndifficulty: medium\nconcepts: This snippet is in Python, not Dafny, so it doesn't contain Dafny-specific concepts or formal verification principles. However, I can provide general programming concepts from this Python code:\n\nfunction definition, type hinting, docstring documentation, parameter handling, conditional logic, dictionary manipulation, OrderedDict usage, string formatting\n\n### Task", "id": 341460, "sha1": "cb0cf03efa3e97bfae8f62f0a1c9c0a1332240b9", "seed": "from typing import OrderedDict\n\n\ndef state_to_ordereddict(st, include_iminfo=True):\n    \"\"\"Represents a state as an OrderedDict\n\n    Parameters\n    ----------\n        st : :class:``peri.states.State``\n            The state to represent.\n        include_iminfo : Bool, optional\n            If set, includes two additional keys, ``'image.filename'`` and\n            ``'image.tile'`` with corresponding info about the image.\n            Default is True.\n\n    Returns\n    -------\n        ``collections.OrderedDict``\n    \"\"\"\n    od = OrderedDict()\n    for p in st.params:\n        od.update({p:st.state[p]})\n    if include_iminfo:\n        od.update({ 'image.filename':st.image.filename,\n                    'image.tile':str(st.image.tile)})\n    return od", "concepts": ["This snippet is in Python", "not Dafny", "so it doesn't contain Dafny-specific concepts or formal verification principles. However", "I can provide general programming concepts from this Python code:\n\nfunction definition", "type hinting", "docstring documentation", "parameter handling", "conditional logic", "dictionary manipulation", "OrderedDict usage", "string formatting"], "instruction": "I understand that you're looking for Dafny programming tasks that focus on verification. I'll create a series of tasks that meet your criteria, incorporating formal verification concepts naturally. Here are the tasks:\n\n## Task 1\n### Properties\ncategory: function implementation\nlanguage: Dafny\ndifficulty: easy\nconcepts: function specification, preconditions, postconditions, integer arithmetic\n\n### Task\nImplement a function called `AbsoluteDifference` that takes two integers as input and returns their absolute difference. Ensure that your function is properly specified and verified to work correctly for all possible integer inputs, including handling potential overflow scenarios.\n\n## Task 2\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: method specification, loop invariants, array manipulation, quantifiers\n\n### Task\nImplement a method called `RemoveDuplicates` that takes an array of integers as input and modifies it in-place to remove all duplicate elements, preserving the original order of elements. The method should return the new length of the array after removing duplicates. Prove that your implementation correctly removes all duplicates and maintains the relative order of the remaining elements.\n\n## Task 3\n### Properties\ncategory: class implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: class invariants, dynamic frames, method contracts, abstraction functions, representation invariants\n\n### Task\nDesign and implement a `PriorityQueue` class that supports the following operations: `Enqueue`, `Dequeue`, and `Peek`. The priority queue should store integer values, where lower values have higher priority. Implement the class using an array-based heap data structure. Ensure that your implementation maintains the heap property and prove the correctness of all operations.\n\n## Task 4\n### Properties\ncategory: method implementation\nlanguage: Dafny\ndifficulty: medium\nconcepts: recursive functions, inductive proofs, method specification, preconditions and postconditions\n\n### Task\nImplement a recursive method called `IsPalindrome` that determines whether a given string is a palindrome (reads the same forwards and backwards, ignoring spaces and punctuation). Prove the correctness of your implementation using induction, and ensure that it handles edge cases correctly.\n\n## Task 5\n### Properties\ncategory: program implementation\nlanguage: Dafny\ndifficulty: hard\nconcepts: graph representation, depth-first search, termination proofs, loop invariants, ghost variables\n\n### Task\nImplement a program that detects cycles in a directed graph. Represent the graph using an adjacency list, and implement a depth-first search algorithm to detect cycles. Prove that your algorithm correctly identifies the presence or absence of cycles in any given graph, and ensure termination for all possible inputs.\n\nThese tasks cover a range of difficulties and concepts in Dafny, focusing on formal verification without explicitly stating which features to use. They encourage logical thinking and formal reasoning while exploring various aspects of program correctness."}
